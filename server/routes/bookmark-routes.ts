import type { Express } from 'express';
import { z } from 'zod';
import { storage } from '../storage';
import { requireAuth, comparePasswords } from '../auth';
import { insertBookmarkSchema } from '@shared/schema';
import type { BookmarkLanguage } from '@shared/schema';
import {
  getUserId,
  verifyProtectedBookmarkAccess,
  getUserFromBearer,
  getAiChargeDecision,
  tryConsumeAiUsage,
  bulkDeleteSchema,
  bulkMoveSchema,
} from './shared';

// Background AI processing function
async function processAiFeaturesInBackground(
  userId: string,
  bookmarkId: number,
  url: string,
  name: string,
  description: string | null,
  language: string | null,
  tags: string[],
  wantTags: boolean,
  wantDesc: boolean,
  overwriteDesc: boolean,
) {
  try {
    // Process AI features in parallel
    const promises = [];

    if (wantDesc) {
      promises.push(
        (async () => {
          try {
            const decision = await getAiChargeDecision(userId, 'desc');
            if (decision.shouldCharge) {
              const usage = await tryConsumeAiUsage(userId);
              if (!usage.ok) return;
            }

            const preferences = await storage.getUserPreferences(userId);
            const preferenceLanguage = preferences?.defaultAiLanguage;
            const resolvedLanguage =
              language ||
              (preferenceLanguage && preferenceLanguage !== 'auto'
                ? preferenceLanguage
                : undefined);
            const languageForGeneration =
              resolvedLanguage ?? (preferenceLanguage === 'auto' ? undefined : 'en');
            const suggested = await storage.generateAutoDescription(
              url,
              name,
              description || undefined,
              { userId, language: languageForGeneration },
            );
            if (suggested && (overwriteDesc || !description)) {
              await storage.updateBookmark(userId, bookmarkId, { description: suggested });
            }
          } catch (error) {
            console.error('Background AI description failed:', error);
          }
        })(),
      );
    }

    if (wantTags) {
      promises.push(
        (async () => {
          try {
            const decision = await getAiChargeDecision(userId, 'tags');
            if (decision.shouldCharge) {
              const usage = await tryConsumeAiUsage(userId);
              if (!usage.ok) return;
            }

            const suggestedTags = await storage.generateAutoTags(
              url,
              name,
              description || undefined,
              { userId },
            );
            await storage.updateBookmarkSuggestedTags(userId, bookmarkId, suggestedTags);
          } catch (error) {
            console.error('Background AI tags failed:', error);
          }
        })(),
      );
    }

    // Wait for all AI processing to complete
    await Promise.all(promises);
    console.log(`Background AI processing completed for bookmark ${bookmarkId}`);
  } catch (error) {
    console.error('Background AI processing failed:', error);
  }
}

export function registerBookmarkRoutes(app: Express) {
  // Extension create bookmark endpoint supporting optional AI
  app.post('/api/ext/bookmarks', async (req, res) => {
    try {
      const user = await getUserFromBearer(req);
      if (!user) return res.status(401).json({ message: 'Authentication required' });
      const userId = (user as any).id as string;

      // Accept tags as array or comma-separated string
      const payload = { ...req.body };
      if (typeof payload.tags === 'string') {
        payload.tags = payload.tags
          .split(',')
          .map((s: string) => s.trim())
          .filter((s: string) => s.length > 0);
      }
      if (payload.language === '') {
        payload.language = null;
      }

      const baseSchema = insertBookmarkSchema
        .pick({
          name: true,
          url: true,
          description: true,
          tags: true,
          isFavorite: true,
          passcode: true,
          categoryId: true,
          language: true,
        })
        .extend({
          autoGenerateTags: z.boolean().optional(),
          autoGenerateDescription: z.boolean().optional(),
          overwriteDescription: z.boolean().optional(),
        });
      const data = baseSchema.parse(payload);
      const userPreferences = await storage.getUserPreferences(userId);
      const preferenceLanguage = userPreferences?.defaultAiLanguage;
      const fallbackLanguage =
        preferenceLanguage && preferenceLanguage !== 'auto' ? preferenceLanguage : undefined;

      let name = data.name;
      let url = data.url;
      let description = data.description || null;
      let tags = Array.isArray(data.tags) ? data.tags : [];
      const categoryId = data.categoryId || null;
      const isFavorite = data.isFavorite ?? false;
      const passcode = (data as any).passcode as string | null | undefined;
      const aiLanguage = data.language ?? fallbackLanguage ?? undefined;
      const languageForStorage = (aiLanguage ?? 'en') as BookmarkLanguage;
      const wantTags = (data as any).autoGenerateTags === true;
      const wantDesc = (data as any).autoGenerateDescription === true;
      const overwriteDesc = (data as any).overwriteDescription === true;

      // Create bookmark immediately without AI processing
      const created = await storage.createBookmark(userId, {
        name,
        url,
        description,
        tags,
        categoryId,
        isFavorite,
        language: languageForStorage,
        passcode: passcode ?? undefined,
      } as any);

      // Process AI features in background if requested
      if (wantTags || wantDesc) {
        // Don't await - let it run in background
        processAiFeaturesInBackground(
          userId,
          created.id,
          url,
          name,
          description,
          aiLanguage ?? null,
          tags,
          wantTags,
          wantDesc,
          overwriteDesc,
        );
      }

      return res.status(201).json(created);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid bookmark data', errors: error.errors });
      }
      console.error('Extension create bookmark failed:', error);
      return res.status(500).json({ message: 'Failed to create bookmark' });
    }
  });

  // Bookmark routes
  app.get('/api/bookmarks', async (req, res) => {
    try {
      const userId = getUserId(req);
      const search = req.query.search as string;
      const categoryIdParam = (req.query.categoryId as string | undefined)?.toLowerCase();
      let categoryId: number | null | undefined = undefined;
      if (
        categoryIdParam === 'uncategorized' ||
        categoryIdParam === 'unspecified' ||
        categoryIdParam === 'none' ||
        categoryIdParam === 'null'
      ) {
        categoryId = null;
      } else if (categoryIdParam) {
        const parsed = parseInt(categoryIdParam);
        categoryId = isNaN(parsed) ? undefined : parsed;
      }
      const isFavorite = req.query.isFavorite === 'true' ? true : undefined;
      const tags = req.query.tags ? (req.query.tags as string).split(',') : undefined;
      const linkStatus = req.query.linkStatus as string;
      const sortBy = (req.query.sortBy as 'name' | 'createdAt' | 'isFavorite') || 'createdAt';
      const sortOrder = (req.query.sortOrder as 'asc' | 'desc') || 'desc';
      const limit = req.query.limit ? parseInt(req.query.limit as string) : undefined;
      const offset = req.query.offset ? parseInt(req.query.offset as string) : undefined;

      const bookmarks = await storage.getBookmarks(userId, {
        search,
        categoryId,
        isFavorite,
        tags,
        linkStatus,
        sortBy,
        sortOrder,
        limit: typeof limit === 'number' && !Number.isNaN(limit) ? limit : undefined,
        offset: typeof offset === 'number' && !Number.isNaN(offset) ? offset : undefined,
      });

      res.json(bookmarks);
    } catch (error) {
      console.error('Error fetching bookmarks:', error);
      res.status(500).json({ message: 'Failed to fetch bookmarks' });
    }
  });

  // Export bookmarks (place before :id route to avoid param conflict)
  app.get('/api/bookmarks/export', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const format = (req.query.format as string) || 'json';
      // Optional category filter
      const categoryIdParam = (req.query.categoryId as string | undefined)?.toLowerCase();
      let categoryId: number | null | undefined = undefined;
      if (
        categoryIdParam === 'uncategorized' ||
        categoryIdParam === 'unspecified' ||
        categoryIdParam === 'none' ||
        categoryIdParam === 'null'
      ) {
        categoryId = null;
      } else if (categoryIdParam) {
        const parsed = parseInt(categoryIdParam);
        categoryId = isNaN(parsed) ? undefined : parsed;
      }

      const all = await storage.getBookmarks(userId, { categoryId });
      if (format === 'csv') {
        const header = [
          'name',
          'description',
          'url',
          'tags',
          'suggestedTags',
          'isFavorite',
          'categoryId',
          'passcodeHash',
          'screenshotUrl',
          'screenshotStatus',
          'screenshotUpdatedAt',
          'linkStatus',
          'httpStatus',
          'lastLinkCheckAt',
          'linkFailCount',
          'category',
        ].join(',');
        const rows = all.map((b) => {
          const tags = (b.tags || []).join('|');
          const suggestedTags = (b.suggestedTags || []).join('|');
          const cat = b.category?.name || '';
          const esc = (v: string | number | null | undefined) => {
            if (v === null || v === undefined) return '""';
            return '"' + String(v).replace(/"/g, '""') + '"';
          };
          return [
            esc(b.name),
            esc(b.description),
            esc(b.url),
            esc(tags),
            esc(suggestedTags),
            b.isFavorite ? '1' : '0',
            esc(b.categoryId),
            esc(b.passcodeHash),
            esc(b.screenshotUrl),
            esc(b.screenshotStatus),
            esc(b.screenshotUpdatedAt?.toISOString()),
            esc(b.linkStatus),
            esc(b.httpStatus),
            esc(b.lastLinkCheckAt?.toISOString()),
            esc(b.linkFailCount),
            esc(cat),
          ].join(',');
        });
        const csv = [header, ...rows].join('\n');
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', 'attachment; filename="bookmarks.csv"');
        return res.send(csv);
      } else {
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', 'attachment; filename="bookmarks.json"');
        return res.json(
          all.map((b) => ({
            name: b.name,
            description: b.description,
            url: b.url,
            tags: b.tags,
            suggestedTags: b.suggestedTags,
            isFavorite: b.isFavorite,
            categoryId: b.categoryId,
            passcodeHash: b.passcodeHash,
            screenshotUrl: b.screenshotUrl,
            screenshotStatus: b.screenshotStatus,
            screenshotUpdatedAt: b.screenshotUpdatedAt,
            linkStatus: b.linkStatus,
            httpStatus: b.httpStatus,
            lastLinkCheckAt: b.lastLinkCheckAt,
            linkFailCount: b.linkFailCount,
            category: b.category?.name || null,
          })),
        );
      }
    } catch (error) {
      console.error('Export failed:', error);
      res.status(500).json({ message: 'Failed to export bookmarks' });
    }
  });

  app.get('/api/bookmarks/:id', async (req, res) => {
    try {
      const userId = getUserId(req);
      const id = parseInt(req.params.id);
      const bookmark = await storage.getBookmark(userId, id);

      if (!bookmark) {
        return res.status(404).json({ message: 'Bookmark not found' });
      }

      res.json(bookmark);
    } catch (error) {
      console.error('Error fetching bookmark:', error);
      res.status(500).json({ message: 'Failed to fetch bookmark' });
    }
  });

  app.post('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const payload = { ...req.body };
      if (payload?.language === '') {
        payload.language = null;
      }
      const data = insertBookmarkSchema.parse(payload);
      const preferences = await storage.getUserPreferences(userId);
      const preferenceLanguage = preferences?.defaultAiLanguage;
      const fallbackLanguage =
        preferenceLanguage && preferenceLanguage !== 'auto' ? preferenceLanguage : undefined;
      const resolvedLanguage = (data.language ?? fallbackLanguage ?? 'en') as BookmarkLanguage;
      const bookmark = await storage.createBookmark(userId, {
        ...data,
        language: resolvedLanguage,
      });
      res.status(201).json(bookmark);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid bookmark data', errors: error.errors });
      }
      console.error('Error creating bookmark:', error);
      res.status(500).json({ message: 'Failed to create bookmark' });
    }
  });

  // Duplicate a bookmark, preserving attributes (except share link); passcode or password may be required
  app.post('/api/bookmarks/:id/duplicate', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: 'Invalid bookmark ID' });
      }

      // Validate body
      const schema = z.object({ passcode: z.string().optional() });
      const { passcode } = schema.parse(req.body || {});

      // Verify access to protected bookmark
      const accessResult = await verifyProtectedBookmarkAccess(userId, id, passcode, req);
      if (!accessResult.success) {
        return res
          .status(accessResult.error!.status)
          .json({ message: accessResult.error!.message });
      }

      const duplicated = await storage.duplicateBookmark(userId, id);
      res.status(201).json(duplicated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid request data', errors: error.errors });
      }
      console.error('Error duplicating bookmark:', error);
      res.status(500).json({ message: 'Failed to duplicate bookmark' });
    }
  });

  app.patch('/api/bookmarks/:id', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const id = parseInt(req.params.id);

      // Validate bookmark ID
      if (isNaN(id)) {
        return res.status(400).json({ message: 'Invalid bookmark ID' });
      }

      // Determine intent from raw body to avoid schema side-effects
      const rawPayload = { ...req.body };
      if (rawPayload.language === '') {
        rawPayload.language = null;
      }
      const rawKeys = Object.keys(rawPayload || {}).filter(
        (k) => (rawPayload as any)[k] !== undefined,
      );
      const onlyFavoriteToggle = rawKeys.length === 1 && rawKeys[0] === 'isFavorite';

      // Parse and validate the data after the passcode decision
      const data = insertBookmarkSchema.partial().parse(rawPayload);

      if (!onlyFavoriteToggle) {
        // Extract passcode from request body for security verification
        // Allow a separate verifyPasscode field when removing passcode (passcode: null)
        const providedPasscode = (req.body as any)?.verifyPasscode ?? (req.body as any)?.passcode;

        // Verify access for protected bookmarks for other fields
        const accessResult = await verifyProtectedBookmarkAccess(userId, id, providedPasscode, req);
        if (!accessResult.success) {
          return res
            .status(accessResult.error!.status)
            .json({ message: accessResult.error!.message });
        }
      }

      const updateData: Record<string, unknown> = { ...data };
      if (rawKeys.includes('language')) {
        const preferences = await storage.getUserPreferences(userId);
        const preferenceLanguage = preferences?.defaultAiLanguage;
        const fallbackLanguage =
          preferenceLanguage && preferenceLanguage !== 'auto' ? preferenceLanguage : undefined;
        updateData.language = (data.language ?? fallbackLanguage ?? 'en') as BookmarkLanguage;
      }

      // Proceed with update
      const bookmark = await storage.updateBookmark(userId, id, updateData as any);
      res.json(bookmark);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid bookmark data', errors: error.errors });
      }
      console.error('Error updating bookmark:', error);
      res.status(500).json({ message: 'Failed to update bookmark' });
    }
  });

  app.delete('/api/bookmarks/:id', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const id = parseInt(req.params.id);

      // Validate bookmark ID
      if (isNaN(id)) {
        return res.status(400).json({ message: 'Invalid bookmark ID' });
      }

      // Extract passcode from request body for security verification
      const { passcode } = req.body;

      // Verify access for protected bookmarks
      const accessResult = await verifyProtectedBookmarkAccess(userId, id, passcode, req);
      if (!accessResult.success) {
        return res
          .status(accessResult.error!.status)
          .json({ message: accessResult.error!.message });
      }

      // Proceed with deletion if access is granted
      await storage.deleteBookmark(userId, id);
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting bookmark:', error);
      res.status(500).json({ message: 'Failed to delete bookmark' });
    }
  });

  // Passcode verification endpoint
  app.post('/api/bookmarks/:id/verify-passcode', async (req, res) => {
    try {
      const userId = getUserId(req);
      const id = parseInt(req.params.id);

      // Validate bookmark ID
      if (isNaN(id)) {
        return res.status(400).json({ message: 'Invalid bookmark ID' });
      }

      const { passcode } = req.body;

      // Validate passcode input
      if (!passcode || typeof passcode !== 'string') {
        return res.status(400).json({ message: 'Passcode is required and must be a string' });
      }

      if (passcode.length < 4 || passcode.length > 64) {
        return res.status(400).json({ message: 'Invalid passcode format' });
      }

      // Check if bookmark exists first (avoid revealing existence through timing)
      const bookmark = await storage.getBookmark(userId, id);
      if (!bookmark) {
        return res.status(404).json({ message: 'Bookmark not found' });
      }

      // First check bookmark-specific passcode
      let isValid = await storage.verifyBookmarkPasscode(userId, id, passcode);

      // If that fails, allow owner's account password when authenticated
      if (!isValid && req.isAuthenticated && req.isAuthenticated()) {
        try {
          const ok = await comparePasswords(passcode, (req.user as any).password);
          if (ok) isValid = true;
        } catch {
          //
        }
      }

      // Log failed attempts for monitoring
      if (!isValid) {
        console.warn(`Failed passcode attempt for bookmark ${id} from IP ${req.ip}`);
      }

      res.json({ valid: isValid });
    } catch (error) {
      console.error('Error verifying passcode:', error);
      res.status(500).json({ message: 'Failed to verify passcode' });
    }
  });

  // Bookmark sharing endpoints
  app.patch('/api/bookmarks/:id/share', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const id = parseInt(req.params.id);

      // Validate bookmark ID
      if (isNaN(id)) {
        return res.status(400).json({ message: 'Invalid bookmark ID' });
      }

      // Validate request body using Zod
      const shareSchema = z.object({
        isShared: z.boolean(),
      });

      const { isShared } = shareSchema.parse(req.body);

      // Get the bookmark first to check if it exists
      const bookmark = await storage.getBookmark(userId, id);
      if (!bookmark) {
        return res.status(404).json({ message: 'Bookmark not found' });
      }

      // Update bookmark sharing status
      const updatedBookmark = await storage.setBookmarkSharing(userId, id, isShared);
      res.json(updatedBookmark);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid request data', errors: error.errors });
      }
      console.error('Error updating bookmark sharing:', error);
      res.status(500).json({ message: 'Failed to update bookmark sharing' });
    }
  });

  // Public shared bookmark access (no authentication required)
  app.get('/api/shared/:shareId', async (req, res) => {
    try {
      const shareId = req.params.shareId;

      if (!shareId) {
        return res.status(400).json({ message: 'Share ID is required' });
      }

      const sharedBookmark = await storage.getSharedBookmark(shareId);

      if (!sharedBookmark) {
        return res.status(404).json({ message: 'Shared bookmark not found' });
      }

      res.json(sharedBookmark);
    } catch (error) {
      console.error('Error fetching shared bookmark:', error);
      res.status(500).json({ message: 'Failed to fetch shared bookmark' });
    }
  });

  // Verify passcode for shared bookmark and return full details if valid
  app.post('/api/shared/:shareId/verify-passcode', async (req, res) => {
    try {
      const { shareId } = req.params as any;
      const schema = z.object({ passcode: z.string().min(4).max(64) });
      const { passcode } = schema.parse(req.body || {});

      const isValid = await storage.verifySharedPasscode(shareId, passcode);
      if (!isValid) {
        return res.status(401).json({ valid: false });
      }

      const full = await storage.getSharedBookmark(shareId, { full: true });
      if (!full) return res.status(404).json({ message: 'Shared bookmark not found' });
      return res.json({ valid: true, bookmark: full });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid data', errors: error.errors });
      }
      console.error('Error verifying shared passcode:', error);
      res.status(500).json({ message: 'Failed to verify passcode' });
    }
  });

  // Bulk operations for bookmarks
  app.post('/api/bookmarks/bulk/delete', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;

      // Validate request body
      const { ids, passcodes } = bulkDeleteSchema.parse(req.body);

      // If a provided secret equals the owner's password, treat it as authorized and delete directly
      const remainingIds: number[] = [];
      const remainingPasscodes: Record<string, string> = { ...(passcodes || {}) };
      const directDeleteIds: number[] = [];

      if (passcodes && Object.keys(passcodes).length > 0) {
        for (const id of ids) {
          const provided = passcodes[id.toString()];
          if (!provided) {
            remainingIds.push(id);
            continue;
          }
          try {
            const ok = await comparePasswords(provided, (req.user as any).password);
            if (ok) {
              directDeleteIds.push(id);
              delete remainingPasscodes[id.toString()];
            } else {
              remainingIds.push(id);
            }
          } catch {
            remainingIds.push(id);
          }
        }
      } else {
        remainingIds.push(...ids);
      }

      const deletedIds: number[] = [];
      const failed: { id: number; reason: string }[] = [];

      // Perform direct deletes for those validated via account password
      for (const id of directDeleteIds) {
        try {
          await storage.deleteBookmark(userId, id);
          deletedIds.push(id);
        } catch (e) {
          failed.push({ id, reason: 'Failed to delete bookmark' });
        }
      }

      // Use existing bulk path for the rest (supports real passcodes and unprotected items)
      if (remainingIds.length > 0) {
        const result = await storage.bulkDeleteBookmarks(userId, remainingIds, remainingPasscodes);
        deletedIds.push(...result.deletedIds);
        failed.push(...result.failed);
      }

      res.json({ deletedIds, failed });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          message: 'Invalid request data',
          errors: error.errors,
        });
      }
      console.error('Error in bulk delete bookmarks:', error);
      res.status(500).json({ message: 'Failed to delete bookmarks' });
    }
  });

  app.patch('/api/bookmarks/bulk/move', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;

      // Validate request body
      const { ids, categoryId, passcodes } = bulkMoveSchema.parse(req.body);

      // If a provided secret equals the owner's password, treat it as authorized and move directly
      const remainingIds: number[] = [];
      const remainingPasscodes: Record<string, string> = { ...(passcodes || {}) };
      const directMoveIds: number[] = [];

      if (passcodes && Object.keys(passcodes).length > 0) {
        for (const id of ids) {
          const provided = passcodes[id.toString()];
          if (!provided) {
            remainingIds.push(id);
            continue;
          }
          try {
            const ok = await comparePasswords(provided, (req.user as any).password);
            if (ok) {
              directMoveIds.push(id);
              delete remainingPasscodes[id.toString()];
            } else {
              remainingIds.push(id);
            }
          } catch {
            remainingIds.push(id);
          }
        }
      } else {
        remainingIds.push(...ids);
      }

      const movedIds: number[] = [];
      const failed: { id: number; reason: string }[] = [];

      // Perform direct moves for those validated via account password
      for (const id of directMoveIds) {
        try {
          await storage.updateBookmark(userId, id, { categoryId } as any);
          movedIds.push(id);
        } catch (e) {
          failed.push({ id, reason: 'Failed to move bookmark' });
        }
      }

      // Use existing bulk path for the rest (supports real passcodes and unprotected items)
      if (remainingIds.length > 0) {
        const result = await storage.bulkMoveBookmarks(
          userId,
          remainingIds,
          categoryId,
          remainingPasscodes,
        );
        movedIds.push(...result.movedIds);
        failed.push(...result.failed);
      }

      res.json({ movedIds, failed });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          message: 'Invalid request data',
          errors: error.errors,
        });
      }
      console.error('Error in bulk move bookmarks:', error);
      res.status(500).json({ message: 'Failed to move bookmarks' });
    }
  });

  // Import bookmarks (JSON array only)
  app.post('/api/bookmarks/import', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const payload = req.body;
      const categoryIdParam = (req.query.categoryId as string | undefined)?.toLowerCase();
      let targetCategoryId: number | null | undefined = undefined;
      if (
        categoryIdParam === 'uncategorized' ||
        categoryIdParam === 'unspecified' ||
        categoryIdParam === 'none' ||
        categoryIdParam === 'null'
      ) {
        targetCategoryId = null;
      } else if (categoryIdParam) {
        const parsed = parseInt(categoryIdParam);
        targetCategoryId = isNaN(parsed) ? undefined : parsed;
      }
      if (!Array.isArray(payload)) {
        return res.status(400).json({ message: 'Expected an array of bookmarks' });
      }
      let created = 0;
      let categoriesCreated = 0;
      const existingCats = await storage.getCategories(userId);
      const categoryCache = new Map<string, number>(); // Cache for created categories
      const preferences = await storage.getUserPreferences(userId);
      const preferenceLanguage = preferences?.defaultAiLanguage;
      const fallbackLanguage =
        preferenceLanguage && preferenceLanguage !== 'auto' ? preferenceLanguage : undefined;

      for (const item of payload) {
        if (!item || typeof item !== 'object') continue;
        const name = (item.name || '').toString();
        const url = (item.url || '').toString();
        if (!name || !url) continue;
        let categoryId: number | null | undefined = targetCategoryId;
        if (item.category != null && item.category !== '') {
          const categoryName = String(item.category).trim();
          const categoryKey = categoryName.toLowerCase();

          // Check cache first
          if (categoryCache.has(categoryKey)) {
            categoryId = categoryCache.get(categoryKey)!;
          } else {
            // Check existing categories
            const found = existingCats.find((c) => c.name.toLowerCase() === categoryKey);
            if (found) {
              categoryId = found.id;
              categoryCache.set(categoryKey, found.id);
            } else {
              // Create new category
              try {
                const newCategory = await storage.createCategory(userId, {
                  name: categoryName,
                });
                categoryId = newCategory.id;
                categoryCache.set(categoryKey, newCategory.id);
                existingCats.push(newCategory); // Add to existing categories for future lookups
                categoriesCreated++;
              } catch (error) {
                console.error(`Failed to create category "${categoryName}":`, error);
                // Continue without category if creation fails
                categoryId = undefined;
              }
            }
          }
        }
        await storage.createBookmark(userId, {
          name,
          url,
          description: item.description || null,
          tags: Array.isArray(item.tags) ? item.tags : [],
          suggestedTags: Array.isArray(item.suggestedTags) ? item.suggestedTags : [],
          isFavorite: !!item.isFavorite,
          categoryId: categoryId === null ? null : categoryId,
          language: ((item.language as string | null | undefined) ||
            fallbackLanguage ||
            'en') as BookmarkLanguage,
          passcodeHash: item.passcodeHash || null,
          screenshotUrl: item.screenshotUrl || null,
          screenshotStatus: item.screenshotStatus || 'idle',
          screenshotUpdatedAt: item.screenshotUpdatedAt ? new Date(item.screenshotUpdatedAt) : null,
          linkStatus: item.linkStatus || 'unknown',
          httpStatus: item.httpStatus || null,
          lastLinkCheckAt: item.lastLinkCheckAt ? new Date(item.lastLinkCheckAt) : null,
          linkFailCount: item.linkFailCount || 0,
          userId, // ignored by server but typed in schema
        } as any);
        created++;
      }
      res.json({ created, categoriesCreated });
    } catch (error) {
      console.error('Import failed:', error);
      res.status(500).json({ message: 'Failed to import bookmarks' });
    }
  });
}
