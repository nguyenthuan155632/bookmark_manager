import type { Express } from 'express';
import { z } from 'zod';
import { storage } from '../storage';
import { requireAuth, comparePasswords } from '../auth';
import { insertBookmarkSchema } from '@shared/schema';
import { getUserId, verifyProtectedBookmarkAccess, getUserFromBearer, getAiChargeDecision, tryConsumeAiUsage, bulkDeleteSchema, bulkMoveSchema } from './shared';

// Background AI processing function
async function processAiFeaturesInBackground(
  userId: string,
  bookmarkId: number,
  url: string,
  name: string,
  description: string | null,
  tags: string[],
  wantTags: boolean,
  wantDesc: boolean,
  overwriteDesc: boolean
) {
  try {
    // Process AI features in parallel
    const promises = [];

    if (wantDesc) {
      promises.push(
        (async () => {
          try {
            const decision = await getAiChargeDecision(userId, 'desc');
            if (decision.shouldCharge) {
              const usage = await tryConsumeAiUsage(userId);
              if (!usage.ok) return;
            }

            const suggested = await storage.generateAutoDescription(url, name, description || undefined, { userId });
            if (suggested && (overwriteDesc || !description)) {
              await storage.updateBookmark(userId, bookmarkId, { description: suggested });
            }
          } catch (error) {
            console.error('Background AI description failed:', error);
          }
        })()
      );
    }

    if (wantTags) {
      promises.push(
        (async () => {
          try {
            const decision = await getAiChargeDecision(userId, 'tags');
            if (decision.shouldCharge) {
              const usage = await tryConsumeAiUsage(userId);
              if (!usage.ok) return;
            }

            const suggestedTags = await storage.generateAutoTags(url, name, description || undefined, { userId });
            await storage.updateBookmarkSuggestedTags(userId, bookmarkId, suggestedTags);
          } catch (error) {
            console.error('Background AI tags failed:', error);
          }
        })()
      );
    }

    // Wait for all AI processing to complete
    await Promise.all(promises);
    console.log(`Background AI processing completed for bookmark ${bookmarkId}`);
  } catch (error) {
    console.error('Background AI processing failed:', error);
  }
}

export function registerBookmarkRoutes(app: Express) {
  // Extension create bookmark endpoint supporting optional AI
  app.post('/api/ext/bookmarks', async (req, res) => {
    try {
      const user = await getUserFromBearer(req);
      if (!user) return res.status(401).json({ message: 'Authentication required' });
      const userId = (user as any).id as string;

      // Accept tags as array or comma-separated string
      const payload = { ...req.body };
      if (typeof payload.tags === 'string') {
        payload.tags = payload.tags
          .split(',')
          .map((s: string) => s.trim())
          .filter((s: string) => s.length > 0);
      }

      const baseSchema = insertBookmarkSchema
        .pick({ name: true, url: true, description: true, tags: true, isFavorite: true, passcode: true, categoryId: true })
        .extend({
          autoGenerateTags: z.boolean().optional(),
          autoGenerateDescription: z.boolean().optional(),
          overwriteDescription: z.boolean().optional(),
        });
      const data = baseSchema.parse(payload);

      let name = data.name;
      let url = data.url;
      let description = data.description || null;
      let tags = Array.isArray(data.tags) ? data.tags : [];
      const categoryId = data.categoryId || null;
      const isFavorite = data.isFavorite ?? false;
      const passcode = (data as any).passcode as string | null | undefined;
      const wantTags = (data as any).autoGenerateTags === true;
      const wantDesc = (data as any).autoGenerateDescription === true;
      const overwriteDesc = (data as any).overwriteDescription === true;

      // Create bookmark immediately without AI processing
      const created = await storage.createBookmark(userId, {
        name,
        url,
        description,
        tags,
        categoryId,
        isFavorite,
        passcode: passcode ?? undefined,
      } as any);

      // Process AI features in background if requested
      if (wantTags || wantDesc) {
        // Don't await - let it run in background
        processAiFeaturesInBackground(userId, created.id, url, name, description, tags, wantTags, wantDesc, overwriteDesc);
      }

      return res.status(201).json(created);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid bookmark data', errors: error.errors });
      }
      console.error('Extension create bookmark failed:', error);
      return res.status(500).json({ message: 'Failed to create bookmark' });
    }
  });

  // Bookmark routes
  app.get('/api/bookmarks', async (req, res) => {
    try {
      const userId = getUserId(req);
      const search = req.query.search as string;
      const categoryIdParam = (req.query.categoryId as string | undefined)?.toLowerCase();
      let categoryId: number | null | undefined = undefined;
      if (
        categoryIdParam === 'uncategorized' ||
        categoryIdParam === 'unspecified' ||
        categoryIdParam === 'none' ||
        categoryIdParam === 'null'
      ) {
        categoryId = null;
      } else if (categoryIdParam) {
        const parsed = parseInt(categoryIdParam);
        categoryId = isNaN(parsed) ? undefined : parsed;
      }
      const isFavorite = req.query.isFavorite === 'true' ? true : undefined;
      const tags = req.query.tags ? (req.query.tags as string).split(',') : undefined;
      const linkStatus = req.query.linkStatus as string;
      const sortBy = (req.query.sortBy as 'name' | 'createdAt' | 'isFavorite') || 'createdAt';
      const sortOrder = (req.query.sortOrder as 'asc' | 'desc') || 'desc';
      const limit = req.query.limit ? parseInt(req.query.limit as string) : undefined;
      const offset = req.query.offset ? parseInt(req.query.offset as string) : undefined;

      const bookmarks = await storage.getBookmarks(userId, {
        search,
        categoryId,
        isFavorite,
        tags,
        linkStatus,
        sortBy,
        sortOrder,
        limit: typeof limit === 'number' && !Number.isNaN(limit) ? limit : undefined,
        offset: typeof offset === 'number' && !Number.isNaN(offset) ? offset : undefined,
      });

      res.json(bookmarks);
    } catch (error) {
      console.error('Error fetching bookmarks:', error);
      res.status(500).json({ message: 'Failed to fetch bookmarks' });
    }
  });

  // Export bookmarks (place before :id route to avoid param conflict)
  app.get('/api/bookmarks/export', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const format = (req.query.format as string) || 'json';
      // Optional category filter
      const categoryIdParam = (req.query.categoryId as string | undefined)?.toLowerCase();
      let categoryId: number | null | undefined = undefined;
      if (
        categoryIdParam === 'uncategorized' ||
        categoryIdParam === 'unspecified' ||
        categoryIdParam === 'none' ||
        categoryIdParam === 'null'
      ) {
        categoryId = null;
      } else if (categoryIdParam) {
        const parsed = parseInt(categoryIdParam);
        categoryId = isNaN(parsed) ? undefined : parsed;
      }

      const all = await storage.getBookmarks(userId, { categoryId });
      if (format === 'csv') {
        const header = ['name', 'url', 'description', 'tags', 'isFavorite', 'category'].join(',');
        const rows = all.map((b) => {
          const tags = (b.tags || []).join('|');
          const cat = b.category?.name || '';
          const esc = (v: string) => '"' + (v || '').replace(/"/g, '""') + '"';
          return [esc(b.name), esc(b.url), esc(b.description || ''), esc(tags), b.isFavorite ? '1' : '0', esc(cat)].join(',');
        });
        const csv = [header, ...rows].join('\n');
        res.setHeader('Content-Type', 'text/csv');
        res.setHeader('Content-Disposition', 'attachment; filename="bookmarks.csv"');
        return res.send(csv);
      } else {
        res.setHeader('Content-Type', 'application/json');
        res.setHeader('Content-Disposition', 'attachment; filename="bookmarks.json"');
        return res.json(
          all.map((b) => ({
            name: b.name,
            url: b.url,
            description: b.description,
            tags: b.tags,
            isFavorite: b.isFavorite,
            category: b.category?.name || null,
          })),
        );
      }
    } catch (error) {
      console.error('Export failed:', error);
      res.status(500).json({ message: 'Failed to export bookmarks' });
    }
  });

  app.get('/api/bookmarks/:id', async (req, res) => {
    try {
      const userId = getUserId(req);
      const id = parseInt(req.params.id);
      const bookmark = await storage.getBookmark(userId, id);

      if (!bookmark) {
        return res.status(404).json({ message: 'Bookmark not found' });
      }

      res.json(bookmark);
    } catch (error) {
      console.error('Error fetching bookmark:', error);
      res.status(500).json({ message: 'Failed to fetch bookmark' });
    }
  });

  app.post('/api/bookmarks', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const data = insertBookmarkSchema.parse(req.body);
      const bookmark = await storage.createBookmark(userId, data);
      res.status(201).json(bookmark);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid bookmark data', errors: error.errors });
      }
      console.error('Error creating bookmark:', error);
      res.status(500).json({ message: 'Failed to create bookmark' });
    }
  });

  // Duplicate a bookmark, preserving attributes (except share link); passcode or password may be required
  app.post('/api/bookmarks/:id/duplicate', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: 'Invalid bookmark ID' });
      }

      // Validate body
      const schema = z.object({ passcode: z.string().optional() });
      const { passcode } = schema.parse(req.body || {});

      // Verify access to protected bookmark
      const accessResult = await verifyProtectedBookmarkAccess(userId, id, passcode, req);
      if (!accessResult.success) {
        return res
          .status(accessResult.error!.status)
          .json({ message: accessResult.error!.message });
      }

      const duplicated = await storage.duplicateBookmark(userId, id);
      res.status(201).json(duplicated);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid request data', errors: error.errors });
      }
      console.error('Error duplicating bookmark:', error);
      res.status(500).json({ message: 'Failed to duplicate bookmark' });
    }
  });

  app.patch('/api/bookmarks/:id', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const id = parseInt(req.params.id);

      // Validate bookmark ID
      if (isNaN(id)) {
        return res.status(400).json({ message: 'Invalid bookmark ID' });
      }

      // Determine intent from raw body to avoid schema side-effects
      const rawKeys = Object.keys(req.body || {}).filter((k) => (req.body as any)[k] !== undefined);
      const onlyFavoriteToggle = rawKeys.length === 1 && rawKeys[0] === 'isFavorite';

      // Parse and validate the data after the passcode decision
      const data = insertBookmarkSchema.partial().parse(req.body);

      if (!onlyFavoriteToggle) {
        // Extract passcode from request body for security verification
        // Allow a separate verifyPasscode field when removing passcode (passcode: null)
        const providedPasscode = (req.body as any)?.verifyPasscode ?? (req.body as any)?.passcode;

        // Verify access for protected bookmarks for other fields
        const accessResult = await verifyProtectedBookmarkAccess(
          userId,
          id,
          providedPasscode,
          req,
        );
        if (!accessResult.success) {
          return res
            .status(accessResult.error!.status)
            .json({ message: accessResult.error!.message });
        }
      }

      // Proceed with update
      const bookmark = await storage.updateBookmark(userId, id, data);
      res.json(bookmark);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid bookmark data', errors: error.errors });
      }
      console.error('Error updating bookmark:', error);
      res.status(500).json({ message: 'Failed to update bookmark' });
    }
  });

  app.delete('/api/bookmarks/:id', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const id = parseInt(req.params.id);

      // Validate bookmark ID
      if (isNaN(id)) {
        return res.status(400).json({ message: 'Invalid bookmark ID' });
      }

      // Extract passcode from request body for security verification
      const { passcode } = req.body;

      // Verify access for protected bookmarks
      const accessResult = await verifyProtectedBookmarkAccess(userId, id, passcode, req);
      if (!accessResult.success) {
        return res
          .status(accessResult.error!.status)
          .json({ message: accessResult.error!.message });
      }

      // Proceed with deletion if access is granted
      await storage.deleteBookmark(userId, id);
      res.status(204).send();
    } catch (error) {
      console.error('Error deleting bookmark:', error);
      res.status(500).json({ message: 'Failed to delete bookmark' });
    }
  });

  // Passcode verification endpoint
  app.post('/api/bookmarks/:id/verify-passcode', async (req, res) => {
    try {
      const userId = getUserId(req);
      const id = parseInt(req.params.id);

      // Validate bookmark ID
      if (isNaN(id)) {
        return res.status(400).json({ message: 'Invalid bookmark ID' });
      }

      const { passcode } = req.body;

      // Validate passcode input
      if (!passcode || typeof passcode !== 'string') {
        return res.status(400).json({ message: 'Passcode is required and must be a string' });
      }

      if (passcode.length < 4 || passcode.length > 64) {
        return res.status(400).json({ message: 'Invalid passcode format' });
      }

      // Check if bookmark exists first (avoid revealing existence through timing)
      const bookmark = await storage.getBookmark(userId, id);
      if (!bookmark) {
        return res.status(404).json({ message: 'Bookmark not found' });
      }

      // First check bookmark-specific passcode
      let isValid = await storage.verifyBookmarkPasscode(userId, id, passcode);

      // If that fails, allow owner's account password when authenticated
      if (!isValid && req.isAuthenticated && req.isAuthenticated()) {
        try {
          const ok = await comparePasswords(passcode, (req.user as any).password);
          if (ok) isValid = true;
        } catch {
          //
        }
      }

      // Log failed attempts for monitoring
      if (!isValid) {
        console.warn(`Failed passcode attempt for bookmark ${id} from IP ${req.ip}`);
      }

      res.json({ valid: isValid });
    } catch (error) {
      console.error('Error verifying passcode:', error);
      res.status(500).json({ message: 'Failed to verify passcode' });
    }
  });

  // Bookmark sharing endpoints
  app.patch('/api/bookmarks/:id/share', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const id = parseInt(req.params.id);

      // Validate bookmark ID
      if (isNaN(id)) {
        return res.status(400).json({ message: 'Invalid bookmark ID' });
      }

      // Validate request body using Zod
      const shareSchema = z.object({
        isShared: z.boolean(),
      });

      const { isShared } = shareSchema.parse(req.body);

      // Get the bookmark first to check if it exists
      const bookmark = await storage.getBookmark(userId, id);
      if (!bookmark) {
        return res.status(404).json({ message: 'Bookmark not found' });
      }

      // Update bookmark sharing status
      const updatedBookmark = await storage.setBookmarkSharing(userId, id, isShared);
      res.json(updatedBookmark);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid request data', errors: error.errors });
      }
      console.error('Error updating bookmark sharing:', error);
      res.status(500).json({ message: 'Failed to update bookmark sharing' });
    }
  });

  // Public shared bookmark access (no authentication required)
  app.get('/api/shared/:shareId', async (req, res) => {
    try {
      const shareId = req.params.shareId;

      if (!shareId) {
        return res.status(400).json({ message: 'Share ID is required' });
      }

      const sharedBookmark = await storage.getSharedBookmark(shareId);

      if (!sharedBookmark) {
        return res.status(404).json({ message: 'Shared bookmark not found' });
      }

      res.json(sharedBookmark);
    } catch (error) {
      console.error('Error fetching shared bookmark:', error);
      res.status(500).json({ message: 'Failed to fetch shared bookmark' });
    }
  });

  // Verify passcode for shared bookmark and return full details if valid
  app.post('/api/shared/:shareId/verify-passcode', async (req, res) => {
    try {
      const { shareId } = req.params as any;
      const schema = z.object({ passcode: z.string().min(4).max(64) });
      const { passcode } = schema.parse(req.body || {});

      const isValid = await storage.verifySharedPasscode(shareId, passcode);
      if (!isValid) {
        return res.status(401).json({ valid: false });
      }

      const full = await storage.getSharedBookmark(shareId, { full: true });
      if (!full) return res.status(404).json({ message: 'Shared bookmark not found' });
      return res.json({ valid: true, bookmark: full });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: 'Invalid data', errors: error.errors });
      }
      console.error('Error verifying shared passcode:', error);
      res.status(500).json({ message: 'Failed to verify passcode' });
    }
  });

  // Bulk operations for bookmarks
  app.post('/api/bookmarks/bulk/delete', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;

      // Validate request body
      const { ids, passcodes } = bulkDeleteSchema.parse(req.body);

      // If a provided secret equals the owner's password, treat it as authorized and delete directly
      const remainingIds: number[] = [];
      const remainingPasscodes: Record<string, string> = { ...(passcodes || {}) };
      const directDeleteIds: number[] = [];

      if (passcodes && Object.keys(passcodes).length > 0) {
        for (const id of ids) {
          const provided = passcodes[id.toString()];
          if (!provided) {
            remainingIds.push(id);
            continue;
          }
          try {
            const ok = await comparePasswords(provided, (req.user as any).password);
            if (ok) {
              directDeleteIds.push(id);
              delete remainingPasscodes[id.toString()];
            } else {
              remainingIds.push(id);
            }
          } catch {
            remainingIds.push(id);
          }
        }
      } else {
        remainingIds.push(...ids);
      }

      const deletedIds: number[] = [];
      const failed: { id: number; reason: string }[] = [];

      // Perform direct deletes for those validated via account password
      for (const id of directDeleteIds) {
        try {
          await storage.deleteBookmark(userId, id);
          deletedIds.push(id);
        } catch (e) {
          failed.push({ id, reason: 'Failed to delete bookmark' });
        }
      }

      // Use existing bulk path for the rest (supports real passcodes and unprotected items)
      if (remainingIds.length > 0) {
        const result = await storage.bulkDeleteBookmarks(userId, remainingIds, remainingPasscodes);
        deletedIds.push(...result.deletedIds);
        failed.push(...result.failed);
      }

      res.json({ deletedIds, failed });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          message: 'Invalid request data',
          errors: error.errors,
        });
      }
      console.error('Error in bulk delete bookmarks:', error);
      res.status(500).json({ message: 'Failed to delete bookmarks' });
    }
  });

  app.patch('/api/bookmarks/bulk/move', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;

      // Validate request body
      const { ids, categoryId, passcodes } = bulkMoveSchema.parse(req.body);

      // If a provided secret equals the owner's password, treat it as authorized and move directly
      const remainingIds: number[] = [];
      const remainingPasscodes: Record<string, string> = { ...(passcodes || {}) };
      const directMoveIds: number[] = [];

      if (passcodes && Object.keys(passcodes).length > 0) {
        for (const id of ids) {
          const provided = passcodes[id.toString()];
          if (!provided) {
            remainingIds.push(id);
            continue;
          }
          try {
            const ok = await comparePasswords(provided, (req.user as any).password);
            if (ok) {
              directMoveIds.push(id);
              delete remainingPasscodes[id.toString()];
            } else {
              remainingIds.push(id);
            }
          } catch {
            remainingIds.push(id);
          }
        }
      } else {
        remainingIds.push(...ids);
      }

      const movedIds: number[] = [];
      const failed: { id: number; reason: string }[] = [];

      // Perform direct moves for those validated via account password
      for (const id of directMoveIds) {
        try {
          await storage.updateBookmark(userId, id, { categoryId } as any);
          movedIds.push(id);
        } catch (e) {
          failed.push({ id, reason: 'Failed to move bookmark' });
        }
      }

      // Use existing bulk path for the rest (supports real passcodes and unprotected items)
      if (remainingIds.length > 0) {
        const result = await storage.bulkMoveBookmarks(userId, remainingIds, categoryId, remainingPasscodes);
        movedIds.push(...result.movedIds);
        failed.push(...result.failed);
      }

      res.json({ movedIds, failed });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          message: 'Invalid request data',
          errors: error.errors,
        });
      }
      console.error('Error in bulk move bookmarks:', error);
      res.status(500).json({ message: 'Failed to move bookmarks' });
    }
  });

  // Import bookmarks (JSON array only)
  app.post('/api/bookmarks/import', requireAuth, async (req, res) => {
    try {
      const userId = req.user!.id;
      const payload = req.body;
      const categoryIdParam = (req.query.categoryId as string | undefined)?.toLowerCase();
      let targetCategoryId: number | null | undefined = undefined;
      if (
        categoryIdParam === 'uncategorized' ||
        categoryIdParam === 'unspecified' ||
        categoryIdParam === 'none' ||
        categoryIdParam === 'null'
      ) {
        targetCategoryId = null;
      } else if (categoryIdParam) {
        const parsed = parseInt(categoryIdParam);
        targetCategoryId = isNaN(parsed) ? undefined : parsed;
      }
      if (!Array.isArray(payload)) {
        return res.status(400).json({ message: 'Expected an array of bookmarks' });
      }
      let created = 0;
      const existingCats = await storage.getCategories(userId);
      for (const item of payload) {
        if (!item || typeof item !== 'object') continue;
        const name = (item.name || '').toString();
        const url = (item.url || '').toString();
        if (!name || !url) continue;
        let categoryId: number | null | undefined = targetCategoryId;
        if (item.category != null && item.category !== '') {
          const found = existingCats.find(
            (c) => c.name.toLowerCase() === String(item.category).toLowerCase(),
          );
          if (found) categoryId = found.id;
          else if (categoryId === undefined) categoryId = undefined;
        }
        await storage.createBookmark(userId, {
          name,
          url,
          description: item.description || null,
          tags: Array.isArray(item.tags) ? item.tags : [],
          isFavorite: !!item.isFavorite,
          categoryId: categoryId === null ? null : categoryId,
          userId, // ignored by server but typed in schema
        } as any);
        created++;
      }
      res.json({ created });
    } catch (error) {
      console.error('Import failed:', error);
      res.status(500).json({ message: 'Failed to import bookmarks' });
    }
  });
}
